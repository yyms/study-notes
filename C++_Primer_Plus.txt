*C++ Primer Plus 学习笔记

**1.
cin.get()保留换行符到输入队列中，其调用可以使用格式cin.get(name,ArrSize).get()，后面一个不带参数的get()是一个重载变体，可以读取下一个字符，即使是换行符。
cin.getline()读入一行输入，并自动在字符串结尾添加\0，然后丢弃读取的换行符；


**2.C++提供了std::string类，专门用于对字符串的操作
可以将string类识别为一个简单对象，使用 = + 等重载的操作符，使用.size()成员函数返回长度等

**3.C++使用new delete 来分配和释放内存，分配的地址来源于C++的自由分配区内存池（堆 heap）
new成功的话返回分配内存的地址，失败的话返回0(空指针)；delete只是删除new所代表的内存资源，而原先的new返回给的指针变量还是可以使用的（注意现在的指针是悬垂的！！如果要保留的话就初始化成0一定要）
这种方式用在数组中比较好，因为数组大小可以动态的创建释放 int *ptsome = new int [10];  delete [] ptsome;

**4.一般来说，给cout一个指针，它将打印出地址；但是指针类型是char *，将打印字符串。如果想查看字符串的地址，就可以cout << (int *)ptr; 强制转换成别的类型的指针来查看。

**5.inline函数，一般都是在函数定义处加上inline关键字，这里只是给编译器
类的成员函数，如果函数的实现在类的定义中直接出现了，那么这个函数就默认是内联函数了
如果没有，那么可以在定义类的头文件中实现内联函数的时候添加inline关键字就可以了
一个建议而已，系统不一定保证能满足这样的内联需求，比如觉得内联函数过大，调用开销大；或者内联函数不能递归调用

**6.引用——主要用于函数的形参
int rats; int & rodents = rates;   //引用在定义的时候就必须初始化
void swaper(int & a, int & b);
对于正确的函数调用，将没有问题；如果调用的参数不匹配，那么编译器可能会创建临时变量，这样如果你要修改引用参数的值的话，就不会被改变，改变的是临时变量的值。现在只有const类型的引用参数才允许创建临时变量，所以一定要尽量用const！！！
同时，函数的返回值也可以是引用类型的，因为一般的返回值是将结果复制到一个临时的返回存储单元，然后赋值的时候进行一次复制；而引用就直接返回原来的结果，但是需要特别注意的是，引用代表的变量在函数执行结束后，内存单元是否还存在，局部变量肯定不能引用返回的！！！

**7.函数重载
函数的返回值将不作为重载的特征；函数的参数const可以作为重载特征。但是对于形参的类型有一定的限制，如果是一般的形参，是不具有重载特性的，会报重复定义错误，但是如果形参是引用类型和指针类型的话，const和非const的形参是可以作为标识符的。

**8.C++中，const有一个特性，默认的const全局变量是没有外连接性的，就是
const int finger = 10; static const int finger = 10; 
是等价的，这样的特性，让const变量在头文件中定义后，可以被多个文件所包含，且在自己的文件中定义将会是内连接的，不会产生重复定义的错误，而包含自同一个头文件肯定是定义相同的

**9.C++调用C语言，由于C++的重载特性，函数的内部表示方式和C不一样、
extern "C"
void spiff(int);

**10.面向对象的重要特性
抽象
封装和数据隐藏：成员变量私有化，成员方法接口公有化
多态
继承
代码的可重用性

**11.构造函数的调用格式
Stock food = Stock("World Cabbage",250,1.25);
Stock food2 ("World Cabbage",250,1.25);
Stock *pfood = new Stock("World Cabbage",250,1.25);
Stock food3; 
	//调用隐式构造器(没有参数的构造函数)，但是Stock food();不是调用构造函数，而是函数申明。。。
而类对象可以赋值food1=food2;这样将会对每个数据成员进行复制
如果构造函数的参数只有一个，还可以这样调用 Stock food4 = 3;这里其实是使用了一个隐式转换了

**12.const的成员函数
对于函数声明和定义的最后加上const关键字，比如void show() const;这就是承诺在这个方法内部，不会对类的成员变量进行修改（本质就是不能修改this指针指向的成员属性）
因为有可能const Stack food; food.show()的调用就必须满足上诉条件，承诺在调用show()成员函数的过程中，不修改food对象

**13.this 指针：指向调用对象。在函数的后面添加const，实际就是限制使用this指针修改对象的值
const Stock & Stock::topval ( const Stock & s ) const
{
	if(s.total_val > total_val)
		return s;
	else
		return *this;
}

**14.对象数组    
Stock stocks[2] = { Stock("aa",12), Stock("bb",13)};
可以使用这种方式来创建对象数组。虽然这里看似是调用的显式构造器，但内部实现是先使用默认构造器创建数组元素，然后使用后面花括号中的构造函数创建临时对象，再将临时变量的内容复制到相应的元素中去。所以，要创建对象数组，这个类必须要有默认的构造器！

**15.类中使用常量的方式:类声明只是描述了对象的形式，而没有真正创建对象，因此没有存储常量的空间，所以如果要使用常量，可以的方式如下：
a.枚举 enum {Len = 30}; 这是创建枚举类型，在编译程序的时候，编译器会自动替换枚举类型成相应的常量
b.static const in Len = 30; 使用static关键字，常量将存储在静态区而不是对象中，被所有的类对象共享。在类中static变量是不允许在类声明时候赋值的，const除外~

**16.操作符重载：限制，必须要有一个操作数是用户自定义类型的，放置为标准类型定义重载
Time operator+(const Time & t) const; 这样就重载了+操作符，调用的类型可以是
t3 = t1 + t2;	//操作符的左边是调用的对象，操作符的右边是传递的参数
t3 = t1.operator+(t2);
甚至是 t4 = t1 + t2 + t3 <-> t4 = t1.operator+(t2.operator+(t3));

**17.友元 friend 让非类成员可以像类成员一样可以访问类的私有属性
实例重载 + << 操作符
friend Time operator+(double m, const Time & t); //类声明中
Time operator+ (double m, const Time & t) { 
    return t + double; 
}  // 实现，没有friend关键字，也没有类域限制符
<< 的重载
void operator<< (ostream & os, const Time & t);  // cout << t1;
ostream & operator<< (ostream & os, const Time & t) { 
    …  return os;
} // cout << t1 << "haha" << t2 << endl;

**18.类的static成员:在类中只能声明，在其他文件中进行初始化，因为类只表示了怎么分配内存，并没有实际的分配内存保存变量
(static const 是个例外，可以在类声明中初始化变量)
static int num_strings;
int StringBad::num_strings = 1; //xxx.cpp  初始化的时候需要提供类限定符，但是不用再次使用static关键字了

20.C++的隐式成员函数（自动提供的成员函数）
a.默认构造函数（如果没有自定义构造函数）：带参数的构造函数也可以是默认构造函数，主要参数都有默认值提供，但是只能有一个默认构造函数
b.复制构造函数(如果没有定义)：用于将一个对象复制到新创建的对象中，它是在初始化过程中调用的，而不是常规的赋值，原型
Class_name (const Class_name &);
下面罗列了调用情况
StringBad ditto(motto);
StringBad metto = motto;
StringBad also = StringBad(motto);
StringBad* pStr = new StringBad(motto);
c.赋值操作符(如果没有定义)
d.默认析构函数(如果没有定义)
e.地址操作符(如果没有定义)

21.静态成员函数 static
不能通过对象调用静态成员函数，因为静态成员函数没有this指针；只能使用静态数据成员；采用类名来调用

22.析构函数调用的时间：
如果对象是动态的，那么在执行完创建对象的语句块后，析构函数自动被调用
如果对象是静态的，那么程序结束时将调用对象的析构函数
如果对象使用new创建的，那么仅当显式使用delete时候才调用析构函数

23.成员初始化列表
Classy::Classy(int n, int m) : mem1(n), mem2(0), mem3(n*m+2);
这些初始化工作是在对象创建时完成的，此时还没有调用构造函数花括号中的代码，必须用这种方式来初始化非静态const数据成员和引用数据成员。初始化顺序同成员在类中声明的顺序相同，而与初始化器顺序无关。

24.创建派生类对象时，基类对象首先被创建。基类的构造函数必须被调用
RatedPlayer::RatedPlayer (unsigned int r, const char* fn, const char* ln, bool ht) : TableTennisPlayer(fn,ln,ht) 
{ rating = r; }
RatedPlayer::RatedPlayer (unsigned int r, const char* fn, const char* ln, bool ht) //: TableTennisPlayer() 
{ rating = r; }   //如果没有显式的调用基类的构造函数，那么默认的基类构造函数将被调用
RatedPlayer::RatedPlayer (unsigned int r, const char* fn, const char* ln, bool ht) : TableTennisPlayer(fn,ln,ht)， rating(r) { } //初始化列表也是可以的
析构函数刚好相反，先调用派生类的析构函数，然后再调用基类的析构函数

25.基类指针和引用可以在不显式转换的情况下指向或者引用派生类对象，只是这些指针或者引用只能用于操作基类的方法
这种情况还可以出现在：调用的函数参数是基类的指针或者引用，可以传递派生类的对象
base_obj = child_obj;  派生类的对象还可以赋值给基类对象，这样将child_obj的基类部分复制给基类对象base_obj

26.多态：指的同一个方法在派生类和基类中的行为不同，同一个方法的行为应当随调用的上下文而异，实现的路径：派生类中重新定义基类的方法；使用虚方法
虚方法(virtual) 
对于函数声明时候没有使用virtual关键字，如果指针或者引用调用方法而不是通过对象调用，那么调用的方法是根据指针或者引用的类型来调用的
如果使用了virtual关键字，指针或者引用调用的方法是根据具体的指向的或者引用的对象决定的
通常为基类的函数声明为虚方法，且继承的派生类也自动是虚方法；习惯上也将申明一个虚析构函数
因为析构函数是根据对象的类型释放资源的，只有虚函数才能保证正确对象类的析构函数被调用

27.派生类方法中调用基类方法 BaseClass::method(); 否则直接调用将是递归调用哦~

28.构造函数不能是虚函数——派生类对象创建时，调用派生类自己的构造函数，过程中将会调用基类的构造函数。因此派生类和基类的构造函数没有继承关系，所以没必要是虚函数
析构函数总应当是虚函数，除非类不用做基类而派生别的类（即使你声明的虚函数什么都不做）
友元不能是虚函数，因为友元不是类成员。友元可以派生类强制转换成基类的指针或者引用而调用基类的友元

29.基类函数隐藏
a.派生类重新定义基类的方法，应当确保通原来基类的函数原型完全相同（返回时基类引用或者指针，就修改成派生类的引用或者指针）
b.如果在派生类中要重新定义基类方法，应该重新定义所有的版本，否则没有显式定义的重载版本将会被全部隐藏

30.纯虚函数
virtual double Area() const = 0; //pure virtual function
当类声明中有纯虚函数时，不能创建该类的对象，只能作为基类，称作抽象类。实际上可以将抽象类看做是一种必须实施的接口，要求派生类必须覆盖自己的纯虚函数，实现这些必须的接口规则

31.对于函数调用，参数能是引用或者指针的，就用引用或者指针，这样可以减小开销 const保护可更改
返回的时候，也应该尽量返回引用，但是如果是函数内部创建的局部对象，这时候就不能返回引用了，因为函数调用结束，对象就已经不存在了
const Stock & Stock::topval (const Stock & s ) const {
	return s; // return *this; }

32.关于继承
构造函数不能被继承，派生类可以使用初始化列表调用基类构造函数
析构函数也不能被继承，释放派生类对象时，先调用派生类的析构函数，然后调用基类的析构函数
赋值操作符也是不能被继承的
